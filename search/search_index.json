{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>A lightweight, type-safe query builder for Bun. Built with performance and developer experience in mind.</p>"},{"location":"#supported-drivers","title":"Supported Drivers","text":"<ul> <li>PostgreSQL</li> <li>SQLite</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>bun add bun-spark\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Fast: Built on Bun's high-performance runtime</li> <li>Type-safe: Full TypeScript support with comprehensive type definitions and compile-time null/undefined prevention</li> <li>Simple: Intuitive query builder API</li> <li>Transactions: Full transaction support with automatic rollback</li> <li>Tested: Comprehensive test suite with real database integration</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"PostgreSQLSQLite <pre><code>import { spark } from 'bun-spark'\nconst db = spark({\ndriver: 'postgres'\nhost: 'localhost',\nport: 5432,\ndatabase: 'my_database',\nusername: 'postgres',\npassword: 'password'\n})\n// `db` is a query builder instance\nconst isConnected = await db.testConnection()\nconsole.log('Connected:', isConnected)\nconst users = await db.table('users').where('id', 1).get()\nconsole.log(users)\n</code></pre> <pre><code>import { spark } from 'bun-spark'\nconst db = spark({\ndriver: 'sqlite'\nfilename: 'db.sqlite'\n})\n// `db` is a query builder instance\nconst isConnected = await db.testConnection()\nconsole.log('Connected:', isConnected)\nconst users = await db.table('users').where('id', 1).get()\nconsole.log(users)\n</code></pre>"},{"location":"model/","title":"Model","text":"<p>Bun Spark Model is a simple, yet powerful ORM (Object-Relational Mapper) that allows you to interact with your database tables in an object-oriented way. It is built on top of the query builder and provides a simple and elegant way to perform CRUD operations.</p>"},{"location":"model/#defining-a-model","title":"Defining a Model","text":"<p>To define a model, you need to create a class that extends the <code>Model</code> class and use the <code>@column</code> decorator to define the table columns.</p> <pre><code>import { Model, column } from 'bun-spark'\nclass User extends Model {\n@column({ primary: true })\npublic id: number\n@column()\npublic name: string\n@column()\npublic email: string\n}\n</code></pre> <p>By default, Bun Spark will use the pluralized version of the class name as the table name. In this case, the table name will be <code>users</code>. You can customize the table name by adding a static <code>tableName</code> property to the model.</p> <pre><code>class User extends Model {\npublic static override tableName = 'my_users'\n// ...\n}\n</code></pre>"},{"location":"model/#column-decorator","title":"Column decorator","text":"<p>The <code>@column</code> decorator is used to define the table columns. It accepts an options object with the following properties:</p> <ul> <li><code>primary</code>: A boolean that indicates if the column is a primary key.</li> <li><code>name</code>: The name of the column in the database. By default, it is the same as the property name.</li> <li><code>serializeAs</code>: The name of the property in the serialized object. By default, it is the same as the property name.</li> <li><code>serialize</code>: A function that allows you to transform the value of the column when serializing the model.</li> </ul> <pre><code>class User extends Model {\n@column({ primary: true })\npublic id: number\n@column({\nname: 'full_name',\nserializeAs: 'full_name',\nserialize: (value: string) =&gt; `My name is ${value}`,\n})\npublic name: string\n@column()\npublic email: string\n}\n</code></pre>"},{"location":"model/#creating-a-new-record","title":"Creating a new record","text":"<p>You can create a new record in the database using the <code>create</code> static method.</p> <pre><code>const user = await User.create({\nname: 'John Doe',\nemail: 'john.doe@example.com',\n})\n</code></pre> <p>The <code>create</code> method will return a new instance of the model with the <code>id</code> property set.</p> <p>You can also use the <code>insert</code> method to insert multiple records at once.</p> <pre><code>const users = await User.insert([\n{ name: 'John Doe', email: 'john.doe@example.com' },\n{ name: 'Jane Doe', email: 'jane.doe@example.com' },\n])\n</code></pre>"},{"location":"model/#finding-records","title":"Finding records","text":"<p>You can find a record by its primary key using the <code>find</code> static method.</p> <pre><code>const user = await User.find(1)\n</code></pre> <p>You can find all records in the table using the <code>all</code> static method.</p> <pre><code>const users = await User.all()\n</code></pre>"},{"location":"model/#querying-records","title":"Querying records","text":"<p>You can use the <code>query</code> static method to create a new query builder instance for the model.</p> <pre><code>const users = await User.query()\n.where('name', 'like', '%John%')\n.get()\n</code></pre>"},{"location":"model/#updating-records","title":"Updating records","text":"<p>You can update a record by changing its properties and calling the <code>save</code> method.</p> <pre><code>const user = await User.find(1)\nuser.name = 'John Smith'\nawait user.save()\n</code></pre>"},{"location":"model/#deleting-records","title":"Deleting records","text":"<p>You can delete a record by calling the <code>delete</code> method.</p> <pre><code>const user = await User.find(1)\nawait user.delete()\n</code></pre> <p>You can also delete records using the query builder.</p> <pre><code>await User.query().where('name', 'John Doe').delete()\n</code></pre>"},{"location":"model/#serializing-a-model","title":"Serializing a model","text":"<p>You can serialize a model to a plain JavaScript object using the <code>serialize</code> method.</p> <pre><code>const user = await User.find(1)\nconst data = user.serialize()\n</code></pre>"},{"location":"model/#transactions","title":"Transactions","text":"<p>You can use transactions with models by calling the <code>useTransaction</code> static method.</p> <pre><code>const trx = await db.beginTransaction()\ntry {\nawait User.useTransaction(trx).create({\nname: 'John Doe',\nemail: 'john.doe@example.com'\n})\nawait trx.commit()\n} catch(e) {\nawait trx.rollback()\n}\n</code></pre>"},{"location":"query-builder/","title":"Basic Queries","text":""},{"location":"query-builder/#insert","title":"insert","text":"<p>Single record</p> <pre><code>const users = await db.table('users')\n.insert({ name: 'John Doe', email: 'john.doe@example.com' })\n</code></pre> <p>Multiple records</p> <pre><code>const users = await db.table('users')\n.insert([\n{ name: 'John Doe', email: 'john.doe@example.com' },\n{ name: 'Jane Doe', email: 'jane.doe@example.com' }\n])\n</code></pre>"},{"location":"query-builder/#update","title":"update","text":"<pre><code>const user = await db.table('users')\n.where('id', 1)\n.update({ name: 'John Doe', email: 'john.doe@example.com' })\n</code></pre>"},{"location":"query-builder/#delete","title":"delete","text":"<pre><code>const user = await db.table('users')\n.where('id', 1)\n.delete()\n</code></pre>"},{"location":"query-builder/#upsert","title":"upsert","text":"<p>Note: The table must have a unique constraint on the conflict column(s) for upsert to work properly.</p> <pre><code>const user = await db.table('users')\n.onConflict('id')\n.upsert({ id: 1, name: 'John Doe', email: 'john.doe@example.com' })\nconst user = await db.table('users')\n.onConflict(['email', 'name'])\n.upsert({ name: 'John Doe', email: 'john.doe@example.com' })\n</code></pre>"},{"location":"query-builder/#all","title":"all","text":"<pre><code>const users = await db.table('users')\n.get()\nconst users = await db.table('users')\n.all()\n// output \n[\n{\nname: 'John Doe',\nemail: 'john.doe@example.com'\nage: 25\n}\n]\n</code></pre>"},{"location":"query-builder/#select","title":"select","text":"<p>The <code>select</code> method allows selecting columns from the database table. You can either pass an array of columns or pass them as multiple arguments.</p> <pre><code>const users = await db.table('users')\n.select(['name', 'email'])\n.get()\n</code></pre> <pre><code>const users = await db.table('users')\n.select('name', 'email')\n.get()\n</code></pre> <p>You can define aliases for the columns using the as expression or passing an object of key-value pair.</p> <pre><code>const users = await db.table('users')\n.select('name as user_name', 'email as user_email')\n.get()\n</code></pre> <pre><code>const users = await db.table('users')\n.select({ // Key is alias name\nuser_name: 'name', user_email: 'email' })\n.get()\n// output\n[\n{\nuser_name: 'John Doe',\nuser_email: 'john.doe@example.com'\n}\n]\n</code></pre>"},{"location":"query-builder/#first","title":"first","text":"<p>The select queries always return an array of objects, even when the query is intended to fetch a single row. However, using the first method will give you the first row or null (when there are no rows).</p> <pre><code>const user = await db.table('users')\n.where('id', 1)\n.first()\n// output\n{\nname: 'John Doe',\nemail: 'john.doe@example.com'\nage: 25\n}\n</code></pre>"},{"location":"query-builder/#where","title":"where","text":"<p>The where method is used to define the where clause in your SQL queries. The query builder accepts a wide range of arguments types to let you leverage the complete power of SQL.</p> <pre><code>const users = await db.table('users')\n.where('active', true)\n.where('age', '&gt;', 25)\n.where('name', 'like', '%John%')\n.get()\n</code></pre> <p>You can create where groups by passing a callback to the where method. For example:</p> <pre><code>const query = db\n.table('users')\n.where((query) =&gt; {\nquery\n.where('username', 'James Bond')\n.whereNull('deleted_at')\n})\n.orWhere((query) =&gt; {\nquery\n.where('email', 'james@example.com')\n.whereNull('deleted_at')\n})\n</code></pre>"},{"location":"query-builder/#wherein","title":"whereIn","text":"<p>The whereIn method is used to define the wherein SQL clause. The method accepts the column name as the first argument and an array of values as the second argument.</p> <pre><code>const users = await db.table('users')\n.whereIn('id', [1, 2, 3])\n.get()\n</code></pre>"},{"location":"query-builder/#wherenull","title":"whereNull","text":"<p>The whereNull method adds a where null clause to the query.</p> <pre><code>const users = await db.table('users')\n.whereNull('age')\n.get()\n</code></pre> <p>The whereNotNull method adds a where not null clause to the query.</p>"},{"location":"query-builder/#wherenotnull","title":"whereNotNull","text":"<pre><code>const users = await db.table('users')\n.whereNotNull('age')\n.get()\n</code></pre>"},{"location":"query-builder/#wherenotin","title":"whereNotIn","text":"<p>The whereNotIn method adds a where not in clause to the query.</p> <pre><code>const users = await db.table('users')\n.whereNotIn('id', [1, 2, 3])\n.get()\n</code></pre>"},{"location":"query-builder/#orwhere","title":"orWhere","text":"<p>The where method is used to define the where clause in your SQL queries. The query builder accepts a wide range of arguments types to let you leverage the complete power of SQL.</p> <pre><code>const users = await db.table('users')\n.where('active', '=', true)\n.orWhere('age', '&gt;', 25)\n.get()\n</code></pre>"},{"location":"query-builder/#orwherein","title":"orWhereIn","text":"<p>The whereIn method is used to define the wherein SQL clause. The method accepts the column name as the first argument and an array of values as the second argument.</p> <pre><code>const users = await db.table('users')\n.where('active', '=', true)\n.OrWhereIn('id', [1, 2, 3])\n.get()\n</code></pre>"},{"location":"query-builder/#orwherenull","title":"orWhereNull","text":"<p>The whereNull method adds a where null clause to the query.</p> <pre><code>const users = await db.table('users')\n.where('active', '=', true)\n.orWhereNull('age')\n.get()\n</code></pre> <p>The whereNotNull method adds a where not null clause to the query.</p>"},{"location":"query-builder/#orwherenotnull","title":"orWhereNotNull","text":"<pre><code>const users = await db.table('users')\n.where('active', '=', true)\n.orWhereNotNull('age')\n.get()\n</code></pre>"},{"location":"query-builder/#orwherenotin","title":"orWhereNotIn","text":"<p>The whereNotIn method adds a where not in clause to the query.</p> <pre><code>const users = await db.table('users')\n.where('active', '=', true)\n.orWhereNotIn('id', [1, 2, 3])\n.get()\n</code></pre>"},{"location":"query-builder/#wherebetween","title":"whereBetween","text":"<p>The whereBetween method adds a where between clause to the query.</p> <pre><code>const users = await db.table('users')\n.where('active', '=', true)\n.whereBetween('age', [25, 30])\n.get()\n</code></pre> <p><code>whereBetween</code> method variants</p> Method Description <code>whereBetween</code> Adds a where between clause to the query. <code>orWhereBetween</code> Adds a where between clause to the query. <code>whereNotBetween</code> Adds a where not between clause to the query. <code>orWhereNotBetween</code> Adds a where not between clause to the query."},{"location":"query-builder/#wherelike","title":"whereLike","text":"<p>The whereLike method adds a where like clause to the query.</p> <pre><code>const users = await db.table('users')\n.whereLike('name', '%John%')\n.get()\n</code></pre> <p><code>whereLike</code> method variants</p> Method Description <code>whereLike</code> Adds a where like clause to the query. <code>orWhereLike</code> Adds a or where like clause to the query. <code>whereNotLike</code> Adds a where not like clause to the query. <code>orWhereNotLike</code> Adds a or where not like clause to the query."},{"location":"query-builder/#whereilike","title":"whereILike","text":"<p>The whereILike method adds a where ilike clause to the query.</p> <pre><code>const users = await db.table('users')\n.whereILike('name', '%johnson')\n.get()\n</code></pre> <p><code>whereILike</code> method variants</p> Method Description <code>whereILike</code> Adds a where ilike clause to the query. <code>orWhereILike</code> Adds a or where ilike clause to the query. <code>whereNotILike</code> Adds a where not ilike clause to the query. <code>orWhereNotILike</code> Adds a or where not ilike clause to the query."},{"location":"query-builder/#whereraw","title":"whereRaw","text":"<p>You can use the whereRaw method to express conditions not covered by the existing query builder methods. Always make sure to use bind parameters to define query values.</p> <pre><code>const users = await db.table('users')\n.whereRaw('age &gt; ?', [25])\n.orWhereRaw('name = ?', ['John Doe'])\n.get()\n</code></pre>"},{"location":"query-builder/#orderby","title":"orderBy","text":"<p>The orderBy method is used to sort the results of the query.</p> <pre><code>const users = await db.table('users')\n.orderBy('name', 'desc') // or 'asc'\n.get()\n</code></pre>"},{"location":"query-builder/#groupby","title":"groupBy","text":"<p>The groupBy method is used to group the results of the query.</p> <pre><code>const users = await db.table('users')\n.groupBy('name')\n.get()\n</code></pre>"},{"location":"query-builder/#having","title":"having","text":"<p>The having method is used to filter the results of the query after the groupBy method is applied.</p> <pre><code>const users = await db.table('users')\n.groupBy('users.id')\n.having('age', '&gt;=', 25)\n</code></pre> <pre><code>const users = await db\n.table('users')\n.select('age', 'count(*) as count')\n.groupBy('users.age')\n.havingRaw('count(*) &gt;= ?', [2])\n.get()\n</code></pre>"},{"location":"query-builder/#limit","title":"limit","text":"<p>The limit method is used to limit the number of results returned by the query.</p> <pre><code>const users = await db.table('users')\n.limit(10)\n.get()\n</code></pre>"},{"location":"query-builder/#offset","title":"offset","text":"<p>The offset method is used to skip a number of results in the query.</p> <pre><code>const users = await db.table('users')\n.offset(5)\n.get()\n</code></pre>"},{"location":"query-builder/#transactions","title":"Transactions","text":"<p>Bun ORM supports both automatic and manual transaction management.</p>"},{"location":"query-builder/#callback-automatic-transactions","title":"Callback (Automatic) Transactions","text":"<p>The <code>transaction</code> method provides an easy way to run database transactions. It accepts a callback function, and if the callback throws an exception, the transaction is automatically rolled back. Otherwise, the transaction is committed if the callback runs successfully.</p> <pre><code>// Successful transaction\nconst result = await db.transaction(async (trx) =&gt; {\n// Insert data\nawait trx\n.table('users')\n.insert({ name: 'John Doe', email: 'john@example.com' })\n// Update data\nawait trx\n.table('users')\n.where('name', '=', 'John Doe')\n.update({ age: 30 })\n// Return final result\nreturn await trx\n.table('users')\n.where('name', '=', 'John Doe')\n.first()\n})\n</code></pre> <p>If an error is thrown inside the transaction callback, the transaction will be automatically rolled back.</p> <pre><code>// Failed transaction (automatic rollback)\ntry {\nawait db.transaction(async (trx) =&gt; {\nawait trx\n.table('users')\n.insert({ name: 'Jane Smith', email: 'jane@example.com' })\n// This will fail and cause rollback\nawait trx.rawQuery('INSERT INTO users (name) VALUES (NULL)')\n})\n} catch (error) {\nconsole.log('Transaction rolled back:', error.message)\n}\n</code></pre>"},{"location":"query-builder/#manual-transactions","title":"Manual Transactions","text":"<p>For more control over the transaction lifecycle, you can use manual transactions. The <code>beginTransaction</code> method starts a new transaction, and you can use the <code>commit</code> and <code>rollback</code> methods to control the outcome.</p> <pre><code>// Manual transaction with commit\nconst trx = await db.beginTransaction()\ntry {\nawait trx\n.table('users')\n.where('name', 'John')\n.update({ age: 30 })\nawait trx.commit()\n} catch (error) {\nawait trx.rollback()\nconsole.log('Transaction rolled back:', error.message)\n}\n</code></pre> <pre><code>// Manual transaction with rollback\nconst trx = await db.beginTransaction()\ntry {\nawait trx\n.table('users')\n.where('name', 'John')\n.update({ age: 25 })\n// Some operation that might fail\nthrow new Error('Something went wrong')\nawait trx.commit()\n} catch (error) {\nawait trx.rollback()\nconsole.log('Transaction rolled back:', error.message)\n}\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":"<ul> <li> Multiple database support<ul> <li> PostgreSQL</li> <li> SQLite</li> <li> MySQL</li> </ul> </li> <li> Manual transaction support</li> <li> Model<ul> <li> Create</li> <li> Insert</li> <li> Insert Many</li> <li> Update</li> <li> Delete</li> <li> Upsert</li> <li> Find</li> <li> All</li> <li> First</li> <li> Save</li> </ul> </li> <li> Aggregation functions<ul> <li> COUNT</li> <li> SUM</li> <li> AVG</li> <li> MIN</li> <li> MAX</li> </ul> </li> <li> Model Relationships<ul> <li> One to One</li> <li> One to Many</li> <li> Many to Many</li> <li> Polymorphic</li> <li> Has Many Through</li> <li> Has One Through</li> <li> Morph One</li> <li> Morph Many</li> </ul> </li> <li> More Query Builder Methods<ul> <li>[*] whereLike</li> <li>[*] whereILike</li> <li>[*] whereNotLike</li> <li>[*] whereNotILike</li> <li> whereBetween</li> <li> whereNotBetween</li> <li> whereExists</li> <li> whereNotExists</li> <li>[*] having</li> <li>[*] havingRaw</li> </ul> </li> <li> Advanced JOIN builder</li> </ul>"}]}